# C++ Stack과 Queue

## Index
- 특별한 자료 구조
- 원소들을 순회할 수 없다
- `<algorithm>`의 함수는 사용할 수 없다
- 일반적으로 가능한 동작
  - `.push()`, `.pop()`
  - `.top()` / `.front()`, `.back()`
  - `.size()`, `.empty()`
- Stack의 사용례
- Queue의 사용례

## 특별한 자료 구조
큐와 스택은 비록 내부 구현은 `vector` 또는 `list`로 이루어져 있을지라도, 각 컨테이너에서 사용 가능한 기능을 동일하게 사용할 수 없다. 왜냐하면 스택과 큐는 사용되는 방식이 미리 정해져있는 특별한 자료 구조이기 때문이다.

> 자세한 것은 컨테이너 어댑터에 대하여 검색하자.

## 원소들을 순회할 수 없다
예를 들어, `vector` 컨테이너의 각 요소에 접근하는 경우를 생각해보자. Loop를 사용하여 다음과 같은 코드를 사용할 수 있다.

```cpp
vector<int> list; // { 1, 2, 3, 4, 5 }
for (vector<int>::iterator itr = list.begin() ; itr != list.end() ; ++itr) {
  cout << *itr;
}
```

위에서 보다시피 컨테이너의 경우 `.begin()`과 `.end()`를 통하여 컨테이너의 시작 *지점*을 가리키는 반복자를 얻을 수 있고, 이를 통하여 각 요소에 자유롭게 접근할 수 있다.

하지만 스택과 큐는 **반복자가 제공되지 않는다.** 즉, 아래와 같은 문법은 존재하지 않는다:

```cpp
queue<int>::iterator itr; // 정의되지 않는다
```

본래 스택과 큐의 정의에 따라, 스택은 LIFO, 큐는 FIFO 원칙에 의하여서만 동작한다.

## `<algorithm>`의 함수는 사용할 수 없다
각 요소에 대한 접근이 불가능하며, 반드시 본래 정해진 작동 규칙대로만 이루어져야 하므로, 대부분의 STL 알고리즘을 사용할 수 없다. 코드 작성시, 스택과 큐를 사용하는 경우 이러한 제약을 반드시 염두에 두어야 한다. 예를 들어, `.sort`, `.find` 등과 같은 함수들을 사용할 수 없다.

## 일반적으로 가능한 동작
### `.push()`, `.pop()`
새로운 요소를 삽입하거나 제거하는 동작이다. `.pop()`의 경우, 각 컨테이너의 규칙에 따라 어떤 위치의 요소가 제거될지가 결정된다. 즉, 스택의 경우 마지막으로 들어간 요소, 큐의 경우 먼저 들어간 요소가 제거된다.

주의할 점은, C++에서는 각 동작의 반환값이 없고, 해당 요소의 값을 사용하려면 아래의 `.top()` 등의 함수를 사용해야 한다.

### `.top()` / `.front()`, `.back()`
스택과 큐 각각의 전용 메서드이다. `.top()`은 스택의 가장 최상위 요소의 값을 반환한다. `.front()`/`.back()`은 큐의 맨 앞 또는 맨 뒤 요소를 반환한다. 반환되는 값의 자료형은 **요소 타입의 레퍼런스**이므로 즉시 사용 가능하다.

### `.size()`, `.empty()`
해당 컨테이너의 요소 개수, 비었는지 여부 등을 체크할 수 있다.

## Stack의 사용례

## Queue의 사용례
