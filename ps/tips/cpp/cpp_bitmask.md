# C++ 비트 마스킹 테크닉

## Index
- 비트 마스크 개념
- 사용하는 경우
  - 2진수 관련 처리가 필요할 때
  - 집합에 대한 메모이제이션이 필요할 때
- 주의 사항
  - 연산자 우선 순위
  - bit 개수와 부호(+/-) 여부
- 주로 사용하는 기법
  - 원소 추가: `set |= (1 << n);`
  - 원소 제거: `set &= ~(1 << n);`
  - 원소 존재 여부 확인 `if (set & (1 << n))`
  - 원소의 토글
  - 집합 연산
  - 모든 부분 집합 순회하기 `subset = (set & subset - 1)`
- 예제: 비밀 지도(Programmers Lv1)

## 비트 마스크 개념

> 정수의 이진수 표현을 자료구조로 사용하는 기법

여기서는 정수에 대한 이진수 표현을 통하여 자료구조로 사용하는 기법과 더불어, 이 기법을 사용하는 데에 필요한 비트 연산 테크닉을 정리한다.

## 사용하는 경우

### 2진수 관련 처리가 필요할 때
문제에서 2진수 표기와 관련된 연산을 요구할 때, 입력으로 주어지는 2진수를 전달받아 적절히 처리하는 것이 필요하다. 이때, 전달받은 2진수 입력을 십진수로 변환한 뒤, 비트 연산자를 적절하게 사용하면 실제 2진수 연산을 하듯이 코드를 작성할 수 있다.

### 집합에 대한 메모이제이션이 필요할 때
DP 문제 풀이에서 경우의 수를 탐색할 때, 방문 배열 등을 메모이제이션하는 것이 필요할 수 있다. 이 때, 직접 `map` 등의 자료 구조를 사용하여 메모이제이션하면 성능에 좋지 않다. 대신, 각각의 경우를 2진수 배열과 같이 나타낸 뒤, 십진수로 변환하여 사용하면 된다.

```
// ex) 16개 경우 중 첫번째와 15번째를 선택한 경우
이진수: 1000000000000010
십진수: 2^15 + 2^1
```

하나의 경우는 위와 같이 하나의 십진수로 대응된다. 단, 일반적으로 정수로 사용하는 `int`는 4Byte(32bit) 크기임을 감안하여, 32개 선택지 이상을 만드려면 `long long int`를 사용하는 것이 필요할 수 있다. 물론 이 경우 그만큼의 메모리를 더 사용하게 됨을 염두에 두자.

## 주의 사항
### 연산자 우선 순위

### bit 개수와 부호(+/-) 여부

## 주로 사용하는 기법

> 여기서는 원소의 위치는 0부터 시작한다.

### 원소 추가: `set |= (1 << n);`
```cpp
// n번째 원소 추가
set = set | (1 << n)
```

### 원소 제거: `set &= ~(1 << n);`
```cpp
// n번째 원소 제거
set = set & ~(1 << n);
```
Index|15|14|13|12|11|...|4|3|2|1|0
-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-
set(예시)|1|0|0|1|1|...|1|0|0|1|0
~(1<<n)|1|1|1|1|0|...|1|1|1|1|1
결과|1|0|0|1|0|...|1|0|0|1|1

(n == 11 일 때) 11번째 비트 이외에는 모두 `& 1`로서 그대로 유지된다. 원래 해당 비트가 0이었을 경우 그대로 유지됨에 유의.

### 원소 존재 여부 확인
```cpp
// n번째 원소 확인
if (set & (1 << n)) { ... }
```

여기서 반환값은 `1000...000` 또는 `0000...0000` 중 하나로, 반드시 `true` 또는 `false`로 대응된다.

### 원소의 토글
```cpp
// n번째 원소 토글
set = set ^ (1 << n);
```
Index|15|14|13|12|11|...|4|3|2|1|0
-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-
set(예시)|1|0|0|1|1|...|1|0|0|1|0
^(1<<n)|0|0|0|0|1|...|0|0|0|0|0
결과|1|0|0|1|0|...|1|0|0|1|1

(n == 11 일 때) XOR 연산으로 n번째 비트만 조작.

### 집합 연산
- 합집합: `a | b`
- 교집합: `a & b`
- 차집합: `a & ~b`: b에 있는 겹치는 것들을 a에서 모두 제외

### 모든 부분 집합 순회하기
```cpp
for (int subset = set ; subset ; subset = (set & subset - 1)) {
  // set부터 시작하여, 하나씩 모든 경우의 수를 순회
  // O(2^n)
}
```

`subset`에서 1씩 뺄 때마다 원소를 하나씩 빼거나 더하는 과정이다.

```
11111
11110
11101
11100
...
```

이때, `subsuet == 00...00`인 경우가 제외됨에 유의하자.

## 예제: 비밀 지도 (Programmers Lv1)
