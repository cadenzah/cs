# C++의 STL

## 함수 객체 관련
- 본문:
  - 38-1-가. 함수 객체
- 함수 객체를 만들기 위한 () 연산자 오버로딩:
  - 28-3-사. () 연산자
- 구조체는 (클래스처럼) 타입이다:
  - 25-4-나. 클래스는 타입이다
- 기존 함수는 스택 프레임을, 멤버 함수는 인라인:
  - 25-3-나. 멤버 함수 작성법
  - 16-3-가. 인라인 함수

## 연관(Associate) 컨테이너

> 상대적으로 Map, Set, Hash 등의 자료구조가 개념적으로 낯설어서 정리해본다

- **키**와 **값**처럼 관련있는 데이터를 하나의 쌍으로 저장하는 컨테이너.
- 이진 트리를 사용하여 값들을 정해진 순서에 따라 정렬하여 삽입 및 저장하므로, **검색에 탁월한 이점**이 있다.
  - *검색의 부담이 삽입 시점으로 이동한 셈*.
  - 따라서 *삽입시 위치를 지정해주지 않아도 되며*, 값만 전달하면 알아서 적절하게 정렬된 위치에 삽입해준다.
- 연관 컨테이너의 반복자는 **양방향 반복자**.
  - 검색 및 순회 작업이 아주 빠르므로 임의 접근 필요 없음
- *키의 중복이 가능한지* 여부에 따라 일반 Map, Set과 멀티맵, 멀티셋으로 나뉜다
- `Map`, `Set` 등이 존재
  - Hash Table은 STL에는 존재하지 않는다.

### `pair` 구조체
- `키-값`의 데이터 형태를 나타내기 위한 구조체
  - JS의 속성이 1개인 Object를 생각하면 된다
- `<utility>` 헤더에 포함

### `Set`
- **집합**; 동일한 타입의 데이터를 모아놓은 것
- 키만 저장되며 **값은 저장되지 않는다**.

```cpp
#include <set>
set<int> int_set;
```

#### `Set`으로 객체 저장하기
- 컨테이너 내에서 객체를 비교할 수 있도록 비교 함수를 지정해주어야 한다
  - 그래야 적절한 위치에 삽입 가능
- 해당 객체의 `class`에서 비교 연산자를 오버로딩하거나
- 함수 객체 타입을 정의하여 `Set` 선언시 전달하거나

작성중


## Reference
- http://soen.kr
