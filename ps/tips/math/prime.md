# 소수와 합성수
## Index
- 소수의 정의
- 소수 판별식
- 에라스토테네스의 체

## 소수의 정의
1과 자기자신 이외에는 나누어떨어지는 수가 없다면, 이 수를 소수라고 한다.

> **1은 소수도 합성수도 아니다.**

아래에서 소수 관련 코드를 작성시 1을 항상 예외 처리해주어야 한다.

## 소수 판별식
기본적인 접근 아이디어는 단순하다. 어떤 수 n이 소수인지 판별하려면, n보다 작은 모든 자연수로 n을 나눠보며 1과 자기자신 이외의 수로 나누어지는 경우가 있는지 확인하는 것이다. 만약 그렇다면, 해당 수는 합성수이다.

확인하는 과정은 아래와 같이 정리할 수 있다:

1. 1을 초과하는 수인가? (1은 소수도 합성수도 아니다)
2. 2보다 큰 2의 배수인가? (2는 소수이지만, 2의 배수는 아니다)
2. 3 이상 n 미만의 수로 나누어 떨어지는가?

여기서 n이 커지면, n 미만의 모든 수에 대하여 확인하는 것이 많은 시간이 걸릴 수 있다. 이때 활용할 수 있는 기법이 **n의 제곱근까지만 확인하는 것이다.** 어떤 수 n이 합성수라면 `n == p * q (p <= q)` 꼴로 표현할 수 있고, 여기서 `p <= sqrt(n) <= q`가 성립하기 때문이다. 따라서, 만약 n이 p로 나누어떨어진다면, 그 몫이 q이므로, q에 대한 검사 또한 동시에 이루어지는 셈이다.

이러한 사실을 일반화하면, 나누어 떨어지는지 여부는 n의 제곱근까지만 검사하면 된다. *한번이라도 나누어 떨어지는 수가 존재한다면 이는 합성수이다.*

```cpp
// 백준 1978번
#include <cmath>
bool isPrime(int n) {
  if (n <= 1) return false;
  if (n == 2) return true;
  if (n % 2 == 0) return false;

  for (int div = 3 ; div <= int(sqrt(n)) ; div++)
    if (n % div == 0) return false;
  return true;
}
```

## 에라스토테네스의 체
특정 범위 내의 수 가운데 소수가 몇 개나 존재하는지 판단해야 하는 문제에서 위의 소수 판별식을 사용하는 것은 너무 긴 시간이 필요할 수 있다. 이때 간편하게 활용할 수 있는 것이 에라스토테네스의 체이다.

에라스토테네스의 체 기법의 핵심은 *합성수를 걸러내는 것*이다. 아래와 같은 방식으로 진행된다.

1. 1부터 n까지 각각이 소수인지 여부를 추적할 배열을 만든다.
2. 2부터 n까지 순차적으로, 각 수를 제외한 각 수의 배수들을 목록에서 제거해나간다. 한번 제거된 수는 이후 확인 대상에서 제외된다.

전후 순서에 차이가 있지만, 앞서 소수 판별식에서 사용한 방법과 근본적으로 동일하며, 대상이 여러 수로 확장된 것에만 차이가 있다.

이 과정을 거친 이후 목록에 남은 수들이 소수의 목록이다.

### 구현의 최적화
O(n^2)의 시간 복잡도가 필요한 연산이지만 최적화의 여지가 있다.

1. i의 배수를 제거할 때에, `2 * i`부터 시작하지 않고 `i * i`부터 시작한다. 이유는 간단한데, i의 배수를 조사할 때 `i * i` 이전의 값들은 이전 순회에서 이미 제거됨이 귀납적으로 확인되기 때문이다.

    ```
    // 2의 배수 순회
    (2) 4 6 8 10 12 14 16...
    // 3의 배수 순회
    (3) 6 9 12 ...
    // 4의 배수 순회
    (4) 8 12 16...
    ```

    2의 배수에서 6은 *2의 3번째 배수*이지만, 한편으로는 *3의 2번째 배수*이다. 또한, 12는 *2의 6번째 배수*이자 *4의 4번째 배수*이다. 이처럼 직전 단계에서 그 다음 단계의 일부를 이미 제거하게 되므로, 제거 단계를 일부 생략할 수 있다.

2. 제거할 배수의 순회를 n까지 진행하지 않고 `sqrt(n)`까지 진행한다. 이는 앞서 소수 판별식에서도 활용되었던 기법과 유사하다. i의 배수를 모두 제거하므로, `sqrt(n)` 이후의 값들에 대한 배수는 `sqrt(n)` 이전의 값들에 대한 배수를 제거할 때 이미 이루어진다.

이러한 로직을 적용한 코드는 아래와 같다.

```cpp
// 백준 1929번
#include <vector>
vector<int> genPrimes(int end) {
  vector<int> primes(end + 1);
  primes[1] = -1; // 1은 소수도 합성수도 아니다

  for (int i = 2 ; i <= int(sqrt(end)) ; i++) {
    if (primes[i] == -1)
      continue;
    else {
      for (int j = i * i ; j <= end ; j += i) {
        primes[j] = -1;
      }
    }
  }

  // primes[i] != -1 인 값들은 모두 소수이다
  return primes;
}
```
