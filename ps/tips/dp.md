# 동적 계획법

## Index
- 주의 사항
  - 완전 탐색으로 풀리는 입력인가?
- TL;DR; 전형적인 유형
- 전제 조건
- 메모이제이션 활용 원칙

## 주의 사항

### 완전 탐색으로 풀리는 입력인가?
시간 복잡도가 높더라도 입력이 크지 않아 완전 탐색으로 풀이가 가능한 유형이라면, 굳이 DP를 사용할 이유가 없다.

3중 이상 for문은 나쁜게 아니다...

### 굳이 복잡하게 생각할 필요 있을까? (완전 탐색과 혼동하지 말자)
완전 탐색과 마찬가지로 DP는 재귀적인 구조로 모든 경우를 고려하는 방법이다. 하지만, DP는 기존에 계산한 것을 메모이제이션 하는 것이 핵심 해법이다. **메모이제이션을 적용할 효율적이면서 적절한 방법**이 도출되지 않는다면, 또는 구현이 까다롭거나 바로 생각나지 않는다면, DP로 접근하는 것은 시간 낭비이다.

단순하게 접근해서 풀리는 문제이고, 이로 인한 시간 또는 메모리 초과가 발생하지 않는다면, 좋은 해법이다.

## TL;DR; 전형적인 유형
- Top-down
  - 1149.rgp
  - 맨 끝에서부터 차례대로 문제를 분해해나가는 예시
- Bottom-up
  - 1902.01tile
  - 맨 처음부터 차례대로 계산해나가며 최종적인 답을 구하는 예시
  - 반복적 동적 계획법

## 전제 조건

- 부분 문제들이 순수 함수이어야 함. 즉, 동일 입력 → 동일 출력임을 보장해야 함.

## 메모이제이션 활용 원칙

1. 기저 사례를 코드 상에서 가장 먼저 확인
  - 입력값의 유효성 확인, 가장 마지막 부분 문제인지 등
2. `cache` 배열의 값이 저장되었는지 여부를 배열 상에 표기
  - 예를 들어, 모든 출력값이 양수임이 보장된다면, 아직 계산되지 않은 값을 표기시 `-1`로 표기
  - 아니면, 실제 각각의 메모이제이션 값을 저장
3. 매 부분 문제에서의 답을 가리킬 때 참조형으로 표현. 그러면 오타 방지에 유용
    ```cpp
    int cache[2500][2500];
    ...
    int& ret = cache[a][b];
    ```
