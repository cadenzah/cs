# 분할 정복

## Index
- 선형 탐색 vs. 이분 탐색

> 어떤 입력의 범위가 엄-청나게 크다면 일단 이분 탐색이 필요한지 여부를 의심해보자

## 선형 탐색 vs. 이분 탐색
분할 정복 기법은 문제 풀이에 직접적으로 관련은 없다. 하지만 주어진 시간 복잡도로 시간 초과가 발생하는 경우, 이분 탐색은 동일 입력을 활용하여 더 짧은 시간 안에 답을 찾을 수 있도록 하는 좋은 방법이다.

> 선형 탐색(O(n))보다 더 빠르게! - O(logn)

## 전제 조건
1. 입력들의 대소 비교가 가능해야 한다.
2. 탐색 대상이 포함된 자료 구조가 정렬된 상태이어야 한다.

## 문제 해석

### 1. 이분 탐색 대상을 식별한다
이 대상의 범위는 상-당히 커서, O(n) 이상의 시간 복잡도가 필요한 코드를 사용할 수 없는 경우가 대부분이다. 이런 경우를 식별했다면 대충 눈치를 채야 한다.

물론 입력을 그대로 다루지 않고, 입력에서 비롯된 다른 값이 대상이 될 수도 있다. 적절한 탐색 대상을 찾아 보자.

### 2. 대상의 범위 식별
대상의 범위를 기반을 이분 탐색이 이루어지므로 이 또한 중요하다.

주어진 문제의 답이 될 수 있는 모든 경우를 포괄할 수 있는 범위로 최소/최대값을 잡는다.

### 3. 해당 대상값이 최적해임을 판단할 로직
문제에서 제시된 상황에 적합한 답인지 계산해낼 수 있는 로직이 필요하다. 대상값과 함께 문제에서 주어진 다른 입력, 다른 조건 등을 결합하여 해당값의 적절성 여부를 판단하고, 조건을 만족한다면 해당 대상값을 저장해둔 뒤 이분 탐색의 범위를 업데이트한다. 이런 식으로 이분 탐색이 종료될 때까지 반복한 뒤 최종 결과를 사용한다.

이분 탐색이 해결의 실마리라는 것을 눈치챘더라도, 사실상 이 부분을 해결하지 못하면 다음 탐색으로 나아갈 수 없으므로 어찌 보면 가장 중요한 단계이다.

## 메모리 초과가 난다면?
꼭 모든 경우에 `long long`을 사용할 필요가 없을지도 모른다. 오버플로우가 발생하지 않는 부분들을 최적화 포인트로 잡자.

## 유형
- 백준의 **랜선 자르기(1654)** 문제가 그 전형적인 사용 예시이다.
- **공유기(2110)** 또한 좋은 예시. 이분 탐색으로 *최적해*를 구하는 전형적인 예시. 문제가 처음에는 좀 헷갈린다.
