# DFS와 BFS

DFS와 BFS의 구현을 직접 다루는 문제인 [백준 1260](https://www.acmicpc.net/problem/1260)를 풀며 실전적인 구현 방법을 복습한다.

## TL;DR;
```cpp
#include <queue>

// 방문 배열과 인접 리스트가 필요
bool visited[N+1];
vector<vector<int> > graph(N + 1, vector<int>());

void dfs(int vertex) {
  // vertex 정점을 기존에 방문하였다면, 패스한다
  if (visited[vertex] == true)
    return;
  
  // vertex 정점의 방문 처리
  visited[vertex] = true;

  <현재 정점에서 수행할 작업 수행>

  // 인접한 정점에 대하여 DFS 시도
  for (int i = 0 ; i < graph[vertex].size() ; i++)
    dfs(graph[vertex][i]);
}

void bfs(int vertex) {
  // 방문 완료한 정점들을 기록할 큐 초기화
  // 방문 완료 정점의 인접 정점들을 차례대로 방문 시도
  queue<int> q;

  // BFS를 시작한 정점의 방문 처리
  q.push(vertex);
  visited[vertex] = true;

  while(!q.empty()) {
    // 큐에서 하나씩 정점을 꺼내어 인접 정점을 조사
    // 조사 완료한 정점은 큐에서 제거
    int prev = q.front();
    q.pop();

    <첫번째 정점에 대하여 작업 수행>

    for (int i = 0 ; i < graph[prev].size() ; i++) {
      int cur = graph[prev][i];
      // cur 정점을 기존에 방문하였다면, 패스한다
      if (visited[cur] == true)
        continue;
      
      q.push(cur);
      visited[cur] = true;

      <현재 정점에서 수행할 작업 수행>
    }
  }
}
```

-----

## Index
- 접근 방식
- 연결 그래프 초기화시 팁
  - 0번째 index를 사용하지 않는다
  - 양방향 그래프가 필요한 경우
- 방문 순서
- DFS는 재귀 함수의 `Stack` 구조를 활용
- BFS는 `Queue` 구조를 활용
- 유의할 코드 사항

## 접근 방식

기본적인 DFS와 BFS 문제로 난이도는 쉽지만, 기본인 만큼 제대로 정리해두자.

## 연결 그래프 초기화시 팁

### 0번째 index를 사용하지 않는다

그래프 내의 노드 정보를 입력받을 때에 1부터 시작하는 경우가 있다. 이 경우 답을 출력할 때에도 규칙이 반영되어야 하므로, **그래프를 초기화할 때에 N+1개로 초기화하고**, 0번째 index는 사용하지 않는다. 이렇게 하면 코드가 단순해지고, 직관적인 코드를 작성할 수 있다.

### 양방향 그래프가 필요한 경우

예를 들어, *노드 1* 과 *노드 2* 가 서로 연결되어있다고 입력을 통하여 받았다고 하면, 인접 그래프를 초기화할 때에 양방향 모두 초기화해주면 된다.

```cpp
adj[node1].push_back(node2); // 1 -> 2
adj[node2].push_back(node1); // 2 -> 1
```

## DFS는 재귀 함수의 `Stack` 구조를 활용

1. 시작 노드를 인자로 DFS 실행
```cpp
dfs(V);
```
2. 해당 노드를 방문 처리 및 해당 노드에 대하여 기타 필요 작업 수행
```cpp
visited[vertex] = true;
// 해당 지점에 대하여 필요한 작업 수행
// 재귀적인 함수 호출이 이루어지므로, 인접한 다른 지점은 건드리지 않는다
```
3. 해당 노드에 인접한 노드 중 아직 방문하지 않은 노드들에 대하여 DFS 수행
```cpp
if (!visited[adj[vertex][i]])
```

## 방문 순서
한 정점에서 인접한 정점이 여러 개인 경우, 어떤 순서로 정점을 방문할지 정해야 한다. *정점 번호에 대하여 오름차순*으로 방문하는 것이 일반적이다. 그 외의 경우, 문제에서 제시하는 대로 방문하면 된다.

이 문서에서 사용하는 인접 리스트는 인접 정점이 삽입되어있는 순서대로 방문한다. 따라서 각 정점 별로 인접 정점들의 배열을 적절하게 조절해주면 된다.

```cpp
// 각 정점에서 오름차순으로 정점을 방문
for (int i = 1 ; i <= N ; i++)
  sort(graph[i].begin(), graph[i].end());
```

## BFS는 STL `queue` 활용

### 최초 작업

1. 시작 노드를 인자로 BFS 실행
```cpp
bfs(V);
```
2. 해당 노드를 큐에 `.push()`하고, 방문 처리 및 해당 노드에 대하여 기타 필요 작업 수행
```cpp
q.push(vertex);
visited[vertex] = true;
```

### 반복 작업

1. 앞서 초기화한 큐에서 맨 앞의 노드를 `.pop()`
```cpp
int previous = q.front();
q.pop();
```
2. `.pop()`한 노드에 인접한 노드들 중 아직 방문하지 않은 노드들을 모두 큐에 `.push()`하고, 모두 방문 처리하고, 해당 노드에 대하여 기타 필요 작업 수행
```cpp
for (int i = 0 ; i < graph[previous].size() ; i++) {
  int current = adj[previous][i];
  if (!visited[current]) {
    q.push(current);
    visited[current] = true;
  }
}
```
3. 큐가 빌 때까지 1과 2를 반복

### 잘못된 구현 주의: 방문 처리 시점

앞선 코드에서는 다음 정점을 방문하는 작업을 `for` 문을 돌 때, 즉 큐에 인접 정점을 집어넣을 때에 수행했다. 이는 큐를 *방문 완료한 정점들을 기록하는 큐*로 해석했기 때문이다.

그렇다면, 만약 큐를 *앞으로 순서대로 방문 예정인 정점들을 기록하는 큐*로 해석하면 어떨까? 이 경우, **방문 처리 및 방문시 작업 수행**의 시점이 달라진다.

```cpp
#include <queue>
void bfs (int start) {
  // 앞으로 순서대로 방문 예정인 정점들을 기록할 큐를 생성
  queue<int> q;
  // 시작점을 큐에 넣는다 (첫번째로 방문 예정)
  q.push(start);
  visited[start] = true;

  // 큐를 돌아가며, 모든 정점을 다 방문하고 큐가 빌 때까지 반복한다
  while (!q.empty()) {
    int here = q.front();
    q.pop();
    
    // 방문하지 않았으므로, 우선 방문 처리한다.
    visited[here] = true;
    // 해당 정점에서 할 일을 수행한다

    for (int i = 0 ; i < graph[here].size() ; i++) {
      int there = graph[here][i];

      // 해당 정점을 이미 방문했다면, 다시 방문하지 않는다
      if (visited[there] == true)
        continue;
      
      // 방문하지 않았다면, 방문하기로 예정한다.
      q.push(there);
    }
  }
}
```

결정적인 차이는, 앞서 코드에서는 *큐에 넣을 때에* 방문 처리와 해당 정점 작업을 모두 수행했다. 하지만 새 코드에서는 *큐에서 뽑을 때* 방문 처리 및 해당 정점 작업을 모두 수행한다. 하지만 새 코드를 실행해보면, 틀린 답이 나옴을 확인할 수 있다.

```bash
# 예제 입력
4 5 1
1 2
1 3
1 4
2 4
3 4

# 출력
1 2 3 4 4 4
```

보다시피, 뒤에 4가 더 나오는 이상한 답이 나온다. 왜 그럴까? **새로운 코드에서는 큐에서 정점을 뽑을 때까지는 방문 여부를 확인하지 않는다.** 또한, 어떤 정점에 대하여 **큐에서 뽑는 것(그 과정에서 방문하였음을 체크하는 것)보다 큐에 넣는 것이 더 먼저 이루어진다.** 따라서, 첫 방문시 `visited` 배열의 값을 변경하였더라도, 인접 정점을 조사하는 과정에서 이미 큐에 삽입해버린 정점을 큐에서 제거하는 것이 불가능해진다. 이 과정에서 중복이 발생하는 것이다. 위 예제 출력에서는 `4`가 그러한 예임을 알 수 있다.

결론적으로, BFS에서 큐는 **방문 완료한 정점을 기록한 큐**로 해석하는 것이 맞다.

## 유의할 코드 사항

### `vector`의 `.size()`

push_back 한 만큼의 사이즈만 반환한다. 2차원 이상의 배열을 사용할 때, 내부 배열들 각각에 접근하는 경우 참고하자. 동적 배열이어서 `.size()`가 기대한 대로 동작하지 않는다고 잘못 알고 있었다.
